
import math
import rclpy
from rclpy.node import Node

from nav_msgs.msg import Odometry
from geometry_msgs.msg import Point
from std_srvs.srv import SetBool
from bug2_interface.srv import GoToPoint as Gpsrv
from sensor_msgs.msg import LaserScan
from std_msgs.msg import Bool

from visualization_msgs.msg import Marker
from builtin_interfaces.msg import Duration

class Bug2Controller(Node):
    def __init__(self):
        super().__init__('bug2_controller')

        # service clients
        self.wall_cli = self.create_client(SetBool, '/wall_follower/switch')
        self.goto_cli = self.create_client(Gpsrv, '/go_to_point/switch')

        # topics
        self.goal_reached_pub = self.create_publisher(Bool, 'bug2/goal_reached', 10)
        self.goal_sub = self.create_subscription(Point, 'bug2/next_goal', self.on_next_goal, 10)
        self.marker_pub = self.create_publisher(Marker, '/bug2/mline', 10)

        self.declare_parameter('goal_tol', 0.08)
        self.declare_parameter('block_threshhold', 0.56)
        self.declare_parameter('eps_line', 0.05)

        self.x = None
        self.y = None
        self.front = None

        self.sent_once = False
        self.start = None
        self.goal = None
        self.m = None
        self.m_norm = None
        self.log_tick = 0
        self.mode = None
        self.d_leave = None

        self.current_goal = None
        self.moving = False

        self.block_threshhold = 0.56
        self.goal_tol = 0.08

        # subs
        self.create_subscription(Odometry, '/odom', self.odom_clbk, 20)
        self.create_subscription(LaserScan, '/scan', self.scan_clbk, 10)

        # timer
        self.create_timer(0.2, self.tick)
    
    def have_pose(self) -> bool:
        return (self.x is not None) and (self.y is not None)
    
    def have_goal(self) -> bool:
        return (self.goal is not None)

    def odom_clbk(self, msg: Odometry):
        self.x = msg.pose.pose.position.x 
        self.y = msg.pose.pose.position.y

    def m_line(self):
        if not (self.start and self.m and self.m_norm and self.have_pose()):
            return None
        
        xs, ys = self.start
        mx, my = self.m
        x, y = self.x, self.y

        return abs((x - xs) * my - (y - ys) * mx) / self.m_norm 
    
    def dist_to_goal(self):
        if not (self.have_goal() and self.have_pose()):
            return None

        xg, yg = self.goal
        return math.hypot(xg - self.x, yg - self.y)
    
    # completly generated by chatgpt, purely for visual confirmation.
    # It visualizes the mline and makes it green.  
    def publish_mline_marker(self):
        if not (self.start and self.goal):
            return
        m = Marker()
        m.header.frame_id = 'odom'
        m.header.stamp = self.get_clock().now().to_msg()
        m.ns = 'bug2'
        m.id = 1
        m.type = Marker.LINE_STRIP
        m.action = Marker.ADD
        m.pose.orientation.w = 1.0
        m.scale.x = 0.10                  # line width (meters)
        m.color.r, m.color.g, m.color.b, m.color.a = (0.1, 1.0, 0.1, 0.9)
        m.points = [
            Point(x=self.start[0], y=self.start[1], z=0.02),
            Point(x=self.goal[0],  y=self.goal[1],  z=0.02),
        ]
        m.lifetime = Duration(sec = 0, nanosec = 0)           # forever
        self.marker_pub.publish(m)
    
    def scan_clbk(self, msg: LaserScan):
        r = msg.ranges
        try:
            self.front = min(min(r[354:360] + r[0:6]), 10)
        except Exception:
            self.front = None

    def on_next_goal(self, msg: Point):
        self.goal = (msg.x, msg.y)
        self.sent_once = False
        self.mode = None
        self.start = None
        self.d_leave = None
        self.get_logger().info(f"[bug2_controller] received waypoint -> (x={msg.x:.2f}, y={msg.y:.2f}) in odom")

    def tick(self):
        if self.goal is None:
            return

        # initialize variables and compute mline logic. (start -> goal)
        if (self.start is None) and self.have_pose() and self.have_goal():
            self.start = (self.x, self.y)

            mx = self.goal[0] - self.start[0]
            my = self.goal[1] - self.start[1]

            self.m = (mx, my)
            self.m_norm = math.hypot(mx, my)
            
            # publishes the mline.
            self.publish_mline_marker()

        # simple guard that checks service clients to see if theyre usable
        if not (self.wall_cli.service_is_ready() and self.goto_cli.service_is_ready()):
            self.wall_cli.wait_for_service(timeout_sec = 0.0)
            self.goto_cli.wait_for_service(timeout_sec = 0.0)
            return

        # turn wall follower OFF
        if not self.sent_once:
            wall_req = SetBool.Request()
            wall_req.data = False
            self.wall_cli.call_async(wall_req)

            # turn G2P ON and plots target position (goal)
            goto_req = Gpsrv.Request()
            goto_req.move_switch = True
            gx, gy = self.goal
            goto_req.target_position = Point(x = gx, y = gy, z = 0.0)

            self.goto_cli.call_async(goto_req)

            self.sent_once = True
            self.mode = 'G2P'
            return

        d = self.dist_to_goal()

        # Checks if the goal is reached.
        if self.mode == 'G2P' and (d is not None) and (d <= self.goal_tol):
            req_g = Gpsrv.Request(); req_g.move_switch = False; req_g.target_position = Point()
            self.goto_cli.call_async(req_g)
            self.goal_reached_pub.publish(Bool(data = True))
            self.get_logger().info("[Bug2_Controller] You have reached your goal")
            return
        
        # Leaves the mline and caches how far we were from the goal (d) when we left the mline.
        if self.mode == 'G2P' and (self.front is not None) and (self.front <= self.block_threshhold):
            e = self.m_line() 
            eps = float(self.get_parameter('eps_line').value)
            if ( 
                self.mode == 'G2P'
                and (d is not None)
                and (self.front is not None) and (self.front <= self.block_threshhold)
                and (e is not None) and (e <= eps)
            ):
                self.d_leave = d

            # G2P OFF
            req_g = Gpsrv.Request(); req_g.move_switch = False; req_g.target_position = Point()
            self.goto_cli.call_async(req_g)

            # WF ON
            req_w = SetBool.Request(); req_w.data = True
            self.wall_cli.call_async(req_w)
            self.mode = 'WF'

            return
        
        # back on M-line and closer-than-leave while in WF
        if self.mode == 'WF':
            e = self.m_line()
            eps = float(self.get_parameter('eps_line').value)
            if (e is not None) and (d is not None) and (self.d_leave is not None):
                if(e <= eps) and (d < self.d_leave):
                    if(
                        (e <= eps)
                        and (d + self.goal_tol < self.d_leave)
                        and (self.front is not None) and (self.front > self.block_threshhold)
                    ):

                        # WF OFF
                        req_w = SetBool.Request(); req_w.data = False
                        self.wall_cli.call_async(req_w)

                        # G2P ON
                        req_g = Gpsrv.Request(); req_g.move_switch = True
                        req_g.target_position = Point(x =  self.goal[0], y = self.goal[1], z = 0.0)
                        self.goto_cli.call_async(req_g)

                        self.mode = 'G2P'
                        self.get_logger().info('rejoin: on M-line & closer -> G2P ON')
                        self.d_leave = None
    
def main(args=None):
    rclpy.init(args=args)
    node = Bug2Controller()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
